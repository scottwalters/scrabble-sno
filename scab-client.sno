
* snobol4 -d 100M scab-client.sno

-include 'random.sno'
-include 'http.sno'

        srandomdev()

*       dictfile = 'twl06.txt'                          ;* whole thing
*       dictfile = 'twl06.txt.test'                     ;* part way through a
        dictfile = 'twl06.txt.test2'                    ;* through e

        nums = '-0123456789'

        data('tile.new(tile.letter,tile.id)')

        rack_x = 1620
        rack_y = 200

* sort letters of word        
        define('sortw(str)a,i,j') :(sortw_end)
sortw   a = array(size(str))
sw1     i = i + 1; str len(1) . a<i> = :s(sw1)
        a = sort(a)
sw2     j = j + 1; sortw = sortw a<j> :s(sw2)f(return)
sortw_end   

* subpermutations
        define('subpermutations(str)strlen,sw,i,s1,s2,pat,res,res_i,anagrams,word') :(subpermutations_end)
subpermutations
*       collect()                                                     ;* just gives an error about blowing the stack
*       str = dict<str>                                               ;* can't do this because a random jumble of rack letters probably won't be in the dictionary
        str = sortw(str)
        res = array(100)
        i = 0                                                         ;* index in to ana_dict, looking for matches
        res_i = 0                                                     ;* index in to res, recording results
        pat = pos(0)                                                  ;* pattern gets built as a function of letters in the sorted word we're looking searching for matches for
subpermutations_1
        str len(1) . s1 rem . str                     :f(subpermutations_2)         ;* pick out the next letter from our sorted rack tiles
        pat = pat ( s1 | '' )                         :(subpermutations_1)          ;* add a pattern either match it or not
subpermutations_2
        pat = pat pos( *strlen )                   ;* force it to match through to the end.  the * defers evaluation of strlen and we update this value each loop iteration.  XXX probably a better way to match the end of the string.
subpermutations_3
        i = i + 1
        sw = ana_dict<i>                              :f(subpermutations_last)
        strlen = size(sw)
        sw pat                                        :f(subpermutations_3)
        anagrams = ana< sw >                                          ;* add all of the anagrams to res
subpermutations_4          
        anagrams span(&lcase) . word span(' ') = ''   :f(subpermutations_3)
        res< res_i = res_i + 1 > = word               :(subpermutations_4)
subpermutations_last
        subpermutations = res             :(return)
subpermutations_end


* http_get() modified from HTTP.OPEN() to add user headers

        define("http_get(ioname,host,path,port,headers)") :(http_get_end)
http_get
        port = ident(port) "80"
        output "http_get port = " port
        tcp.open(ioname, host, port, HTTP.RECL)           :f(freturn)
        $ioname = "GET " path " HTTP/1.0" HTTP.CRLF
+               "User-Agent: " HOST() HTTP.CRLF
+               "Host: " host HTTP.CRLF
+               headers
+               HTTP.CRLF                                 :(return)
http_get_end

* move_tile

* curl 'http://slowass.net:11704/?x=1132&y=52&id=card018&action=move' -H 'Host: slowass.net:11704' -H 'User-Agent: Mozilla/5.0 (X11; OpenBSD amd64; rv:56.0) Gecko/20100101 Firefox/66.0' -H 'Accept: */*' -H 'Accept-Language: en-US,en;q=0.5' --compressed -H 'Referer: http://slowass.net:11704/?action=board' -H 'Cookie: sid=42522100784659544515' -H 'DNT: 1' -H 'Connection: keep-alive'

        define('move_tile(tile,x,y)')                     :(move_tile_end)          
move_tile                                
        output = "move tile..."
        http_get( .webfh, 'slowass.net', '/?action=move&id=' tile.id(tile) '&x=' x '&y=' y, 11704, cookies )  :f(http_error)
move_read
        tmp = webfh                                       :s(move_read)
        http.close(.webfh)
                                                          :(return)
move_tile_end

* dump_rack

        define('dump_rack()')                             :(dump_rack_done)
dump_rack
        output = 'rack:'
        i = 0
dump_rack_next
        i = i + 1
        tile = rack<i>                              :f(return)
        letter = differ(tile) tile.letter( tile )                                             ;* if tile isn't null, get the letter off of it   XXX put this in a subroutine I guess
        letter = ident(tile) ' '                                                              ;* if tile is null, use ' '
        output = i ': ' letter                      :(dump_rack_next)
dump_rack_done

* dump_board

        define('dump_board()')                             :(dump_board_done)
dump_board
        y = 0
dump_board_y
        y = lt(y, 15) y + 1                                :f(return)
        x = 0
        out = ''
dump_board_x
        tile = board<x = x + 1, y>
        letter = differ(tile) tile.letter( tile )                                             ;* if tile isn't null, get the letter off of it
        letter = ident(tile) ' '                                                              ;* if tile is null, use ' '
        out = out letter 
        output = eq(x, 15) out
        lt(x, 15)                                          :s(dump_board_x)f(dump_board_y)
dump_board_done

* find_tile_in_rack

        define('find_tile_in_rack(letter),i,tile')         :(find_tile_in_rack_end)
find_tile_in_rack
        i = 0
find_tile_in_rack_next
        tile = rack< i = i + 1 >                           :f(freturn)                       ;* out of positions in the rack to look at
        differ(tile)                                       :f(find_tile_in_rack_next)        ;* skip to the next tile if this one is null
        ident( tile.letter(tile), letter )                 :f(find_tile_in_rack_next)        ;* skip to the next tile if this isn't the one being searched for
        find_tile_in_rack = tile
        rack< i > = ''
                                                           :(return)
find_tile_in_rack_end
     
* draw_rack

* draw tiles as needed but return a string listing the letters we do have.
* if less than a full rack (and it isn't the end of the game), reload the board and call again to see what was drawn.

        define('draw_rack()i,random_sushi,letters')        :(draw_rack_done)
draw_rack
        output = "drawing tiles..."
        i = 0
        random_sushi = -1
        letters = ''
draw_rack_next
        tile = rack< i = i + 1 >                    :f(draw_rack_last)
        differ(tile)                                :f(draw_rack_1)                          ;* branch if tile is empty
        letters = letters tile.letter(tile)         :(draw_rack_next)
draw_rack_1
        output = "drawing a tile for slot " i 
        last_sushi = last_sushi + 1
        random_sushi = remdr( random(), last_sushi )
        move_tile( sushi< random_sushi >, 10, 10 )                                           ;* turn it over before moving it to our rack
        move_tile( sushi< random_sushi >, rack_x, rack_y + ( ( i - 1 ) * 60 ) )
                                                    :(draw_rack_next)
draw_rack_last
        draw_rack = letters                         :(return)
draw_rack_done
     
* read_board

* request the board from the server, and update rack, board, and sushi arrays, their sizes, and board_is_empty.
* we do this after moving tiles instead of trying to model our own concept of the game board across changes.

        define('read_board()i,x,y')                 :(read_board_last)
read_board
        output = "re-reading board..."
        board = array('1:15,1:15')
        sushi = array('1:100')
        rack = array('1:7')

        last_board = 0
        last_tiles = 0
        last_sushi = 0
        board_is_empty = 1
        http_get( .webfh, 'slowass.net', '/?action=board', 11704, cookies )   :f(http_error)
read_board_again
        line = webfh                                             :f(read_board_done)
*       output = line
*       <img id="card095" alt="card095" src="/jpg/_.png" style="position:absolute; left: 616px; top: -9px; z-index: 1396; width: 57px; height: 57px;" onload="Drag.init(this);" >
        line '<img id="' arb . id '" alt="' arb '" src="/jpg/' any('abcdefghijklmnopqrstuvwxyz_') . letter '.png" style="position:absolute; left: ' 
+            span(nums) . x 'px; top: ' span(nums) . y 'px; z-index'
+                                                                :f(read_board_again)
*       output = "found letter " letter " x " x " y " y " id " id

*       undrawn tiles still in the pile
board_sort_tiles_0
        lt( x, 750 ) lt( y, 125 ) gt( y, -30 )                   :f(board_sort_tiles_1)
        sushi< last_sushi = last_sushi + 1 > = tile.new(letter, id)
                                                                 :(read_board_again)
board_sort_tiles_1
         
*       tiles on the board
        gt( x, 195 ) gt( y, 252 ) lt( x, 1104 ) lt( y, 1137 )    :f(board_sort_tiles_2)
*       output = "board:  prelim:  tile " letter " is at " x " " y
        x = 1 + ( ( x - 195 ) / 60 );
        y = 1 + ( ( y - 252 ) / 59 );
*       output = "board:  tile " letter " is at " x " " y
        board<x, y> = tile.new(letter, id)
        board_is_empty = 0
                                                                 :(read_board_again)
board_sort_tiles_2
        eq( x, rack_x ) ge( y, rack_y ) le( y, rack_y + 60 * 7)  :f(board_sort_tiles_3)
      output = "found a tile on our rack at y " y
        y = 1 + ( y - rack_y) / 60
      output = "     that's rack at position " y
        rack<y> = tile.new(letter, id)
                                                                 :(read_board_again)
board_sort_tiles_3
        output = 'XXX tile out of range: ' x ' ' y ' ' letter    :(read_board_again)          ;* unless bugs appear, this is fine... any out of range tile is just in someone's rack
read_board_done
        http.close(.webfh)                                       :(return)
read_board_last

* build_board_rows_and_cols_arrays

        define('build_board_rows_and_cols_arrays()x,y,tile,pat,latter')  :(build_board_rows_and_cols_arrays_end)      ;* XXX kinda need something that traverses an calls a callback
build_board_rows_and_cols_arrays

        board_rows_pat = array('15')                                ;* each row, top to bottom
        board_cols_pat = array('15')                                ;* each column, left to right

        board_rows_text = array('15')                               ;* again but for a text representation
        board_cols_text = array('15')

        y = 0
crawl_board_y
        y = lt(y, 15) y + 1                                :f(return)
        x = 0
crawl_board_x
        tile = board<x = x + 1, y>

        pat = differ(tile) tile.letter( tile )                                             ;* if tile isn't null, get the letter off of it
        pat = ident(tile) len(1)                                                           ;* if tile is null, use len(1)
        board_rows_pat<y> = board_rows_pat<y> pat
        board_cols_pat<x> = board_cols_pat<x> pat

        letter = differ(tile) tile.letter( tile )
        letter = ident(tile) ' '
        board_rows_text<y> = board_rows_text<y> letter
        board_cols_text<x> = board_cols_text<x> letter

*       output = "debug: datatype board_rows y = " y " is " datatype(board_rows<y>)
        lt(x, 15)                                          :s(crawl_board_x)f(crawl_board_y)
build_board_rows_and_cols_arrays_end

* count_invalid_words

* count the number of words on the board that aren't in the dictionary.
* used so that we can make sure that something we're looking at isn't an illegal play.
* call build_board_rows_and_cols_arrays() first so that board_rows_text and board_cols_text arrays are set.

        define('count_invalid_words(),x,y')                :(count_invalid_words_end)
count_invalid_words
        num_invalid_words = 0                                                              ;* we don't have to challenge the player but for now we don't want to add invalid plays

        y = 0
verify_rows_next_row
        row = board_rows_text<y = y + 1>                   :f(verify_rows_done)
verify_rows_next_word
        row arb ( any(&lcase) span(&lcase) ) . word span(' ') = ''
+                                                          :f(verify_rows_next_row)
        output = "word to validate = " word
        output = ident( dict<word> ) "invalid word >" word "<"                                ;* if dict<word> is null; debugging
        num_invalid_words = ident( dict<word> ) num_invalid_words + 1                         ;* if dict<word> is null
                                                           :(verify_rows_next_word)
verify_rows_done

        x = 0
verify_cols_next_col
        col = board_cols_text<x = x + 1>                   :f(verify_cols_done)
verify_cols_next_word
        col arb ( any(&lcase) span(&lcase) ) . word span(' ') = ''
+                                                          :f(verify_cols_next_col)
        output = "word to validate = " word
        output = ident( dict<word> ) "invalid word >" word "<"                                ;* if dict<word> is null; debugging
        num_invalid_words = ident( dict<word> ) num_invalid_words + 1                         ;* if dict<word> is null
                                                           :(verify_cols_next_word)
verify_cols_done
    output = "XXX number invalid words: " num_invalid_words
    count_invalid_words = num_invalid_words                :(return)
count_invalid_words_end

* longest_word

        define('longest_word(arr)word,i')                        :(longest_word_end)
longest_word
        i = 0
        longest_word = ''
longest_word_next
        word = arr< i = i + 1 >                                  :f(return)
        longest_word = gt( size(word), size(longest_word) ) word :(longest_word_next)
longest_word_end

* join_array

        define('join_array(arr)out,i')                     :(join_array_done)
join_array
        out = ''
        i = 0
join_array_next
        out = differ(out) out ' '                          ;* if not empty, add a space
        out = out arr< i = i + 1 >                         :s(join_array_next)
        join_array = out                                   :(return)
join_array_done


*
* main
*

* figure out how many words are in the dictionary so we can allocate arrays for them

        input('dictfh', 10, '', dictfile) :f(end)
read_dict0
        dictsize = dictsize + 1
        tmp = dictfh    :s(read_dict0)

        output = dictsize - 1 ' words in the dictionary'

* build dict, ana, ana_dict, dict_table from the dictionary

        dict = table()                          ;* quickly lookup whether a word exists
        ana = table()                           ;* given an anagram-normalized word (letters sorted), a space separated string of all possible anagrams
        ana_dict = array(dictsize)              ;* each word in anagram-normalized format with its letters sorted lexigraphically, used to find words for a set of tiles
        dictsize = 1                            ;* index into ana_dict while we're reading

        rewind(10)                              ;* re-read the file.  since arrays don't dynamically expand, this is done in two passes, and now we have arrays to put this in.
read_dict1

        word = dictfh                   :f(read_dict2)

*       dict<dictsize> = word                   ;* this used to be an array

        sw = sortw(word)

        dict<word> = sw

        ana_dict<dictsize> = sw

        ana<sw> = ana<sw> word ' '              ;* all possible words for a sorted set of letters

        dictsize = dictsize + 1         :(read_dict1)
read_dict2
        output = "dictsize: " dictsize


        output = "host: " host()


        http_get( .webfh, 'slowass.net', '/', 11704, 'Cookie: sid=' sid HTTP.CRLF )      :f(http_error)
login_page_read
        tmp = webfh                                            :f(login_page_read_done)
        ;*   Set-Cookie: sid=83062304708249829056; path=/; expires=Sun, 13-Jan-2019 21:09:41 GMT
        tmp "Set-Cookie: sid=" span(nums) . sid ';'            :f(login_page_read)
        output = "sid = " sid                                  :(login_page_read)
login_page_read_done
        http.close(.webfh)

        cookies = 'Cookie: sid=' sid HTTP.CRLF

        output = "login page..."

        http_get( .webfh, 'slowass.net', '/?player_id=computer&password=fred&gamepass=wee', 11704, cookies )  :f(http_error)
login_read
        tmp = webfh                      :s(login_read)
*       output = webfh                   :s(login_read)
        http.close(.webfh)

        output = "welcome page..."

        http_get( .webfh, 'slowass.net', '/', 11704, cookies )  :f(http_error)
welcome_page_read
         tmp = webfh                                            :s(welcome_page_read)
*       output = webfh                                          :s(welcome_page_read)
        http.close(.webfh)


*
*       start of main play loop
*

*       we read the board, draw tiles as needed, make a play, then draw tiles again

board_read

        output = "board page..."

        read_board()

* draw as needed

        draw_rack()
        read_board()                                      ;* if draw_rack() did draw, then we need to update our rack, etc from the board
        letters = draw_rack()                             ;* what we have in our hand after possibily drawing and reloading
        output = "rack: " letters

* dump the board

        output = "board:"

        dump_board()

* all possible plays with the letters in our rack

        words = subpermutations(letters)                        ;* XXXXXXXXX testing

        output = "all possible words: " join_array(words)
        

* smack something down onto the board if it's the first turn

        eq(board_is_empty, 1)                              :f(board_is_not_empty)

        output = "board is empty"
*       word = subwords<1,1>
        word = longest_word( words )
        output = "playing " word
        play_len = size(word)
        y = 8
        x = 8 - convert(play_len / 2, 'integer')
first_play
        word len(1) . letter = ''                          :f(first_play_last)
        tile = find_tile_in_rack(letter)                   :f(tile_not_found_error)
        output = "moving " letter " to " x " , " y
        move_tile( tile, 204 + ( ( x - 1 ) * 62), 268 + ( ( y - 1 ) * 61 ) )                      ;* placing tiles on the board may need tweaking XX
        x = x + 1                                          :(first_play)
first_play_last

        draw_rack()

                                                           :(wait_for_the_human)


* board isn't empty so have to try to fit a play on somewhere

board_is_not_empty

        output = "board is not empty"

        build_board_rows_and_cols_arrays()                                                 ;* updates board_rows_pat, board_cols_pat, board_rows_text, board_cols_text arrays

        num_invalid_words = count_invalid_words()

        word = longest_word( words )                   ;* XXX sort these descending by length?  sort() will sort by a field in a multidim array.  or else for now just iterate over them in their current arbitrary order trying to find one that fits anywhere.

* v/ count how many invalid words are on the board
* XXXXXXXXXX loop over words
* XXXXXXXXXXX try to match our words to board_cols_pat/board_rows_pat, which is lame and half-assed.
*     XXXXXXX take letters in the row/col on the board and temp add them to our rack
*                   this is super messy as it lets plays build on existing words, but then we have to check that they didn't have to move that letter to use it
*                                                             but it shouldn't have tried to move the letter if the board_cols_pat/board_rows_pat matched
* XXXXXXXX make a copy of board_cols_text/board_rows_text every time we try to fit a word.  copy() works on arrays.
*          experimentally lay down the word
*          count how many invalid words are on the board again and make sure it hasn't increased


* XXXX dict should point to cached anagram-stemmed words so we only need to run wsort() while loading the dictionary... no, that doesn't work.  jumbles of tiles have to be sorted.
; XXXX dict<> is still used to quickly validate words on the board but AFAIK there's no reason to point it to its anagram stem.  but OTOH re-used strings are cheap in SNOBOL.


* XXXXXXXXXXXXXX make sure everything on the board after that is still a word or else iterate
*       XXX either need a non-stemmed table of the dictionary or else a function to do binary lookups on the dict array


       
* wait for the human

wait_for_the_human

        output = "press enter..."
        tmp = input                                                ;* wait for the human
                                         :(board_read)             ;* loop

*
* error messages
*


http_error
        output = "HTTP something failed"         :(end)

tile_not_found_error
        output = "find_tile_in_rack couldn't locate the tile we wanted"         :(end)


*        output = "tiles: " sortw(word)
*        output = ana< sortw(word) >

*        subwords = subpermutations(sortw(word))
*        subwords = convert( subwords, 'ARRAY' )
*        outstr = outstr ana< subwords<i,1> > ' '     :s(next_subword)


end




* v/ okay, we're logged in, and we have a copy of the board, and we know how to make words from a set of letters in our rack
* v/ need to draw/maintain our rack

* build patterns from the board that we can try to match our words to?
* look for all non-words on the board before play and after considering each play

* need to pick out words that actually attach
*     that could be done by picking a word and seeing if it breaks anything 
* subpermutations maybe needs to know about edges of the board and existing letters
*     then it would have to be able to insert one word in to the middle of that somewhere
*     that would have to iterate over the 15 rows and columns, tracking score (maybe, or just length as a stop-gap), rejecting what doesn't fit    


